<!DOCTYPE HTML><html lang=en class="sidebar-visible no-js light"><head><meta charset=UTF-8><title>Line processing - Perl one-liners cookbook</title><meta content="text/html; charset=utf-8"http-equiv=Content-Type><meta name=description content="Example based guide for text processing with Perl from the command line"><meta name=viewport content="width=device-width, initial-scale=1"><meta name=theme-color content=#ffffff><link rel=icon href=favicon.svg><link rel="shortcut icon"href=favicon.png><link rel=stylesheet href=css/variables.css><link rel=stylesheet href=css/general.css><link rel=stylesheet href=css/chrome.css><link rel=stylesheet href=FontAwesome/css/font-awesome.css><link rel=stylesheet href=fonts/fonts.css><link rel=stylesheet href=highlight.css><link rel=stylesheet href=tomorrow-night.css><link rel=stylesheet href=ayu-highlight.css><link rel=stylesheet href=style.css><body><script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script><script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script><script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script><script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script><nav id=sidebar class=sidebar aria-label="Table of contents"><div class=sidebar-scrollbox><ol class=chapter><li class="chapter-item expanded affix"><a href=cover.html>Cover</a><li class="chapter-item expanded affix"><a href=buy.html>Buy PDF/EPUB versions</a><li class="chapter-item expanded"><a href=preface.html><strong aria-hidden=true>1.</strong> Preface</a><li class="chapter-item expanded"><a href=one-liner-introduction.html><strong aria-hidden=true>2.</strong> One-liner introduction</a><li class="chapter-item expanded"><a href=line-processing.html class=active><strong aria-hidden=true>3.</strong> Line processing</a><li class="chapter-item expanded"><a href=in-place-file-editing.html><strong aria-hidden=true>4.</strong> In-place file editing</a><li class="chapter-item expanded"><a href=field-separators.html><strong aria-hidden=true>5.</strong> Field separators</a><li class="chapter-item expanded"><a href=record-separators.html><strong aria-hidden=true>6.</strong> Record separators</a><li class="chapter-item expanded"><a href=using-modules.html><strong aria-hidden=true>7.</strong> Using modules</a><li class="chapter-item expanded"><a href=multiple-file-input.html><strong aria-hidden=true>8.</strong> Multiple file input</a><li class="chapter-item expanded"><a href=processing-multiple-records.html><strong aria-hidden=true>9.</strong> Processing multiple records</a><li class="chapter-item expanded"><a href=two-file-processing.html><strong aria-hidden=true>10.</strong> Two file processing</a><li class="chapter-item expanded"><a href=dealing-with-duplicates.html><strong aria-hidden=true>11.</strong> Dealing with duplicates</a><li class="chapter-item expanded"><a href=perl-rename-command.html><strong aria-hidden=true>12.</strong> Perl rename command</a><li class="chapter-item expanded"><a href=Exercise_solutions.html><strong aria-hidden=true>13.</strong> Exercise Solutions</a></li><br><hr><li class="chapter-item expanded"><i id=git-repository-button class="fa fa-github"></i><a href=https://github.com/learnbyexample/learn_perl_oneliners>   Source code</a><li class="chapter-item expanded"><i id=home-button class="fa fa-home"></i><a href=https://learnbyexample.github.io/>   My Blog</a><li class="chapter-item expanded"><i id=book-button class="fa fa-book"></i><a href=https://learnbyexample.github.io/books/>   My Books</a></ol></div><div id=sidebar-resize-handle class=sidebar-resize-handle></div></nav><div id=page-wrapper class=page-wrapper><div class=page><div id=menu-bar-hover-placeholder></div><div id=menu-bar class="menu-bar sticky bordered"><div class=left-buttons><button id=sidebar-toggle class=icon-button type=button title="Toggle Table of Contents"aria-label="Toggle Table of Contents"aria-controls=sidebar><i class="fa fa-bars"></i></button><button id=theme-toggle class=icon-button type=button title="Change theme"aria-label="Change theme"aria-haspopup=true aria-expanded=false aria-controls=theme-list><i class="fa fa-paint-brush"></i></button><ul id=theme-list class=theme-popup aria-label=Themes role=menu><li role=none><button role=menuitem class=theme id=light>Light (default)</button><li role=none><button role=menuitem class=theme id=rust>Rust</button><li role=none><button role=menuitem class=theme id=coal>Coal</button><li role=none><button role=menuitem class=theme id=navy>Navy</button><li role=none><button role=menuitem class=theme id=ayu>Ayu</button></ul><button id=search-toggle class=icon-button type=button title="Search. (Shortkey: s)"aria-label="Toggle Searchbar"aria-expanded=false aria-keyshortcuts=S aria-controls=searchbar><i class="fa fa-search"></i></button></div><h1 class=menu-title>Perl one-liners cookbook</h1><div class=right-buttons><a href=https://learnbyexample.github.io title=Blog aria-label=Blog> <i id=home-button class="fa fa-home"></i> </a><a href=https://github.com/learnbyexample/learn_perl_oneliners title="Git repository"aria-label="Git repository"> <i id=git-repository-button class="fa fa-github"></i> </a></div></div><div id=search-wrapper class=hidden><form id=searchbar-outer class=searchbar-outer><input type=search name=search id=searchbar name=searchbar placeholder="Search this book ..."aria-controls=searchresults-outer aria-describedby=searchresults-header></form><div id=searchresults-outer class="searchresults-outer hidden"><div id=searchresults-header class=searchresults-header></div><ul id=searchresults></ul></div></div><script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script><div id=content class=content><main><div class=sidetoc><nav class=pagetoc></nav></div><h1 id=line-processing><a class=header href=#line-processing>Line processing</a></h1><p>Now that you are familiar with basic <code>perl</code> cli usage, this chapter will dive deeper into line processing examples. You'll learn various ways for matching lines based on regular expressions, fixed string matching, line numbers, etc. You'll also see how to group multiple statements and learn about control flow keywords <code>next</code> and <code>exit</code>.<h2 id=regexp-based-filtering><a class=header href=#regexp-based-filtering>Regexp based filtering</a></h2><p>As mentioned before:<ul><li><code>/REGEXP/FLAGS</code> is a shortcut for <code>$_ =~ m/REGEXP/FLAGS</code><li><code>!/REGEXP/FLAGS</code> is a shortcut for <code>$_ !~ m/REGEXP/FLAGS</code></ul><p>If required, you can also use different delimiters. Quoting from <a href=https://perldoc.perl.org/perlop#m/PATTERN/msixpodualngc>perldoc: match</a>:<blockquote><p>If <code>/</code> is the delimiter then the initial <code>m</code> is optional. With the <code>m</code> you can use any pair of non-whitespace (ASCII) characters as delimiters. This is particularly useful for matching path names that contain <code>/</code>, to avoid LTS (<strong>leaning toothpick syndrome</strong>). If <code>?</code> is the delimiter, then a match-only-once rule applies, described in <code>m?PATTERN?</code> below. If <code>'</code> (single quote) is the delimiter, no variable interpolation is performed on the <em>PATTERN</em>. When using a delimiter character valid in an identifier, whitespace is required after the <code>m</code>. <em>PATTERN</em> may contain variables, which will be interpolated every time the pattern search is evaluated, except for when the delimiter is a single quote.</blockquote><pre><code class=language-bash>$ cat paths.txt
/foo/a/report.log
/foo/y/power.log
/foo/abc/errors.log

$ perl -ne 'print if /\/foo\/a\//' paths.txt
/foo/a/report.log

$ perl -ne 'print if m{/foo/a/}' paths.txt
/foo/a/report.log

$ perl -ne 'print if !m#/foo/a/#' paths.txt
/foo/y/power.log
/foo/abc/errors.log
</code></pre><h2 id=extracting-matched-portions><a class=header href=#extracting-matched-portions>Extracting matched portions</a></h2><p>You can use regexp related special variables to extract only the matching portions instead of filtering entire matching line. Consider this input file.<pre><code class=language-bash>$ cat programming_quotes.txt
Debugging is twice as hard as writing the code in the first place.
Therefore, if you write the code as cleverly as possible, you are,
by definition, not smart enough to debug it by Brian W. Kernighan

Some people, when confronted with a problem, think - I know, I will
use regular expressions. Now they have two problems by Jamie Zawinski

A language that does not affect the way you think about programming,
is not worth knowing by Alan Perlis

There are 2 hard problems in computer science: cache invalidation,
naming things, and off-by-1 errors by Leon Bambrick
</code></pre><p>Here's some examples of extracting only the matched portion(s).<pre><code class=language-bash>$ # note that this will print only the first match for each input line
$ perl -nE 'say $& if /\bt\w*[et]\b/' programming_quotes.txt
twice
the
that

$ perl -nE 'say join "::", @{^CAPTURE} if /not (.+)y(.+)/i' programming_quotes.txt
smart enough to debug it b:: Brian W. Kernighan
affect the way ::ou think about programming,
worth knowing b:: Alan Perlis

$ # sometimes capture groups are enough, you don't need special variables
$ # @{^CAPTURE} isn't needed here, as it is assumed that every line has a match
$ perl -nE 'say /^(\w+ ).*?(\d+)$/' table.txt
brown 42
blue 7
yellow 14
$ # or add a custom separator
$ perl -nE 'say join ":", /^(\w+).*?(\d+)$/' table.txt
brown:42
blue:7
yellow:14
</code></pre><h2 id=transliteration><a class=header href=#transliteration>Transliteration</a></h2><p>The transliteration operator <code>tr</code> (or <code>y</code>) allows you to specify per character transformation rule. See <a href=https://perldoc.perl.org/perlop#tr/SEARCHLIST/REPLACEMENTLIST/cdsr>perldoc: tr</a> for documentation.<pre><code class=language-bash>$ # rot13
$ echo 'Uryyb Jbeyq' | perl -pe 'tr/a-zA-Z/n-za-mN-ZA-M/'
Hello World

$ # use 'c' option to complement specified characters
$ echo 'foo:123:baz' | perl -pe 'tr/0-9\n/-/c'
----123----

$ # use 'd' option to delete specified characters
$ echo 'foo:123:baz' | perl -pe 'tr/0-9\n//cd'
123

$ # use 's' option to squeeze repeated characters
$ echo 'APPLE gobbledygook' | perl -pe 'tr|A-Za-z||s'
APLE gobledygok
$ # transliterate as well as squeeze
$ echo 'APPLE gobbledygook' | perl -pe 'tr|A-Z|a-z|s'
aple gobbledygook
</code></pre><p>Similar to <code>s</code> operator, <code>tr</code> will return number of changes made. Use <code>r</code> option to prevent in-place modification and return the transliterated string instead.<pre><code class=language-bash>$ # match lines containing 'b' 2 times
$ perl -ne 'print if tr/b// == 2' table.txt
brown bread mat hair 42

$ s='orange apple appleseed'
$ echo "$s" | perl -pe 's#\bapple\b(*SKIP)(*F)|\w+#$&=~tr/a-z/A-Z/r#ge'
ORANGE apple APPLESEED
</code></pre><p>See also:<ul><li><a href=https://stackoverflow.com/q/45571828/4082052>stackoverflow: reverse complement DNA sequence for a specific field</a><li><a href=https://unix.stackexchange.com/q/396584/109046>unix.stackexchange: count the number of characters except specific characters</a><li><a href=https://unix.stackexchange.com/q/428085/109046>unix.stackexchange: scoring DNA data</a></ul><h2 id=conditional-substitution><a class=header href=#conditional-substitution>Conditional substitution</a></h2><p>These examples combine line filtering and substitution in different ways. As noted before, <code>s</code> operator will modify the input string and the return value can be used to know how many substitutions were made. Use the <code>r</code> flag to prevent in-place modification and get string output after substitution, if any.<pre><code class=language-bash>$ # change commas to hyphens if the input line does NOT contain '2'
$ # prints all input lines even if substitution fails
$ printf '1,2,3,4\na,b,c,d\n' | perl -pe 's/,/-/g if !/2/'
1,2,3,4
a-b-c-d

$ # prints filtered input lines, even if substitution fails
$ perl -ne 'print s/by/**/rg if /not/' programming_quotes.txt
** definition, not smart enough to debug it ** Brian W. Kernighan
A language that does not affect the way you think about programming,
is not worth knowing ** Alan Perlis

$ # print only if substitution succeeded
$ perl -ne 'print if s/1/one/g' programming_quotes.txt
naming things, and off-by-one errors by Leon Bambrick
</code></pre><h2 id=multiple-conditions><a class=header href=#multiple-conditions>Multiple conditions</a></h2><p>It is good to remember that Perl is a programming language. You have control structures and you can combine multiple conditions using logical operators. You don't have to create a single complex regexp.<pre><code class=language-bash>$ perl -ne 'print if /not/ && !/it/' programming_quotes.txt
A language that does not affect the way you think about programming,
is not worth knowing by Alan Perlis

$ perl -ane 'print if /twice/ || $#F > 11' programming_quotes.txt
Debugging is twice as hard as writing the code in the first place.
Some people, when confronted with a problem, think - I know, I will

$ perl -ne 'print if /s/ xor /m/' table.txt
brown bread mat hair 42
yellow banana window shoes 3.14
</code></pre><h2 id=next><a class=header href=#next>next</a></h2><p>When <code>next</code> is executed, rest of the code will be skipped and the next input line will be fetched for processing. It doesn't affect <code>BEGIN</code> or <code>END</code> blocks as they are outside the file content loop.<pre><code class=language-bash>$ perl -nE 'if(/\bpar/){print "%% $_"; next}
            say /s/ ? "X" : "Y"' word_anchors.txt
%% sub par
X
Y
X
%% cart part tart mart
</code></pre><p><strong>Note</strong> that <code>{}</code> is used in the above example to group multiple statements to be executed for a single <code>if</code> condition. You'll see many more examples with <code>next</code> in coming chapters.<h2 id=exit><a class=header href=#exit>exit</a></h2><p>The <code>exit</code> function is useful to avoid processing unnecessary input content when a termination condition is reached. See <a href=https://perldoc.perl.org/functions/exit>perldoc: exit</a> for documentation.<pre><code class=language-bash>$ # quits after an input line containing 'you' is found
$ perl -ne 'print; exit if /you/' programming_quotes.txt
Debugging is twice as hard as writing the code in the first place.
Therefore, if you write the code as cleverly as possible, you are,
$ # matching line won't be printed in this case
$ perl -pe 'exit if /you/' programming_quotes.txt
Debugging is twice as hard as writing the code in the first place.
</code></pre><p>Use <code>tac</code> to get all lines starting from last occurrence of the search string with respect to entire file content.<pre><code class=language-bash>$ tac programming_quotes.txt | perl -ne 'print; exit if /not/' | tac
is not worth knowing by Alan Perlis

There are 2 hard problems in computer science: cache invalidation,
naming things, and off-by-1 errors by Leon Bambrick
</code></pre><p>You can optionally provide a status code as an argument to the <code>exit</code> function.<pre><code class=language-bash>$ printf 'sea\neat\ndrop\n' | perl -ne 'print; exit(2) if /at/'
sea
eat
$ echo $?
2
</code></pre><p>Any code in <code>END</code> block will still be executed before exiting. This doesn't apply if <code>exit</code> was called from the <code>BEGIN</code> block.<pre><code class=language-bash>$ perl -pE 'exit if /cake/' table.txt
brown bread mat hair 42

$ perl -pE 'exit if /cake/; END{say "bye"}' table.txt
brown bread mat hair 42
bye

$ perl -pE 'BEGIN{say "hi"; exit; say "hello"} END{say "bye"}' table.txt
hi
</code></pre><blockquote><p><img src=images/warning.svg alt=warning> Be careful if you want to use <code>exit</code> with multiple input files, as <code>perl</code> will stop even if there are other files remaining to be processed.</blockquote><h2 id=line-number-based-processing><a class=header href=#line-number-based-processing>Line number based processing</a></h2><p>Line numbers can also be specified as a matching criteria using the <code>$.</code> special variable.<pre><code class=language-bash>$ # print only the 3rd line
$ perl -ne 'print if $. == 3' programming_quotes.txt
by definition, not smart enough to debug it by Brian W. Kernighan

$ # print 2nd and 5th line
$ perl -ne 'print if $. == 2 || $. == 5' programming_quotes.txt
Therefore, if you write the code as cleverly as possible, you are,
Some people, when confronted with a problem, think - I know, I will

$ # transliterate only 2nd line
$ printf 'gates\nnot\nused\n' | perl -pe 'tr/a-z/*/ if $. == 2'
gates
***
used

$ # print from particular line number to the end of input
$ seq 14 25 | perl -ne 'print if $. >= 10'
23
24
25
</code></pre><p>Use <code>eof</code> function to check for end of file condition. See <a href=https://perldoc.perl.org/perlfunc#eof>perldoc: eof</a> for documentation.<pre><code class=language-bash>$ # same as: tail -n1 programming_quotes.txt
$ perl -ne 'print if eof' programming_quotes.txt
naming things, and off-by-1 errors by Leon Bambrick

$ perl -ne 'print "$.:$_" if eof' programming_quotes.txt
12:naming things, and off-by-1 errors by Leon Bambrick

$ # multiple file example
$ # same as: tail -q -n1 programming_quotes.txt table.txt
$ perl -ne 'print if eof' programming_quotes.txt table.txt
naming things, and off-by-1 errors by Leon Bambrick
yellow banana window shoes 3.14
</code></pre><p>For large input files, use <code>exit</code> to avoid processing unnecessary input lines.<pre><code class=language-bash>$ seq 3542 4623452 | perl -ne 'if($. == 2452){print; exit}'
5993
$ seq 3542 4623452 | perl -ne 'print if $. == 250; if($. == 2452){print; exit}'
3791
5993

$ # here is a sample time comparison
$ time seq 3542 4623452 | perl -ne 'if($. == 2452){print; exit}' > f1
real    0m0.004s
$ time seq 3542 4623452 | perl -ne 'print if $. == 2452' > f2
real    0m0.740s
</code></pre><h2 id=range-operator><a class=header href=#range-operator>Range operator</a></h2><p>You can use range operator to select between pair of matching conditions like line numbers and regexp. See <a href=https://perldoc.perl.org/perlop#Range-Operators>perldoc: range</a> for documentation.<pre><code class=language-bash>$ # the range is automatically compared against $. in this context
$ # same as: perl -ne 'print if 3 <= $. <= 5'
$ seq 14 25 | perl -ne 'print if 3..5'
16
17
18

$ # the range is automatically compared against $_ in this context
$ # note that all the matching ranges are printed
$ perl -ne 'print if /are/ .. /by/' programming_quotes.txt
Therefore, if you write the code as cleverly as possible, you are,
by definition, not smart enough to debug it by Brian W. Kernighan
There are 2 hard problems in computer science: cache invalidation,
naming things, and off-by-1 errors by Leon Bambrick
</code></pre><blockquote><p><img src=images/info.svg alt=info> See <a href=./processing-multiple-records.html#records-bounded-by-distinct-markers>Records bounded by distinct markers</a> section for an alternate, flexible solution.</blockquote><p>You can also mix line number and regexp conditions.<pre><code class=language-bash>$ perl -ne 'print if 5 .. /use/' programming_quotes.txt
Some people, when confronted with a problem, think - I know, I will
use regular expressions. Now they have two problems by Jamie Zawinski

$ # same logic as: perl -pe 'exit if /ll/'
$ # inefficient, but this will work for multiple file inputs
$ perl -ne 'print if !(/ll/ .. eof)' programming_quotes.txt table.txt
Debugging is twice as hard as writing the code in the first place.
Therefore, if you write the code as cleverly as possible, you are,
by definition, not smart enough to debug it by Brian W. Kernighan

brown bread mat hair 42
blue cake mug shirt -7
</code></pre><blockquote><p><img src=images/warning.svg alt=warning> Both conditions can match the same line too! Also, if the second condition doesn't match, lines starting from first condition to the last line of the input will be matched.</blockquote><pre><code class=language-bash>$ # 'worth' matches the 9th line
$ perl -ne 'print if 9 .. /worth/' programming_quotes.txt
is not worth knowing by Alan Perlis

$ # there's a line containing 'affect' but doesn't have matching pair
$ # so, all lines till the end of input is printed
$ perl -ne 'print if /affect/ .. /XYZ/' programming_quotes.txt
A language that does not affect the way you think about programming,
is not worth knowing by Alan Perlis

There are 2 hard problems in computer science: cache invalidation,
naming things, and off-by-1 errors by Leon Bambrick
</code></pre><h2 id=working-with-fixed-strings><a class=header href=#working-with-fixed-strings>Working with fixed strings</a></h2><p>You can surround a regexp pattern with <code>\Q</code> and <code>\E</code> to match it as a fixed string, similar to <code>grep -F</code> option. <code>\E</code> can be left out if there's no further pattern to be specified. Variables are still interpolated, so if your fixed string contains <code>$</code> or <code>@</code> forming possible variables, you'll run into issues. For such cases, you can pass the string as an environment value and then apply <code>\Q</code> to that variable. See <a href=https://perldoc.perl.org/functions/quotemeta>perldoc: quotemeta</a> for documentation.<pre><code class=language-bash>$ # no match, since [] are character class metacharacters
$ echo 'int a[5]' | perl -ne 'print if /a[5]/'

$ perl -E 'say "\Qa[5]"'
a\[5\]
$ echo 'int a[5]' | perl -ne 'print if /\Qa[5]/'
int a[5]
$ echo 'int a[5]' | perl -pe 's/\Qa[5]/b[12]/'
int b[12]

$ # $y and $z will be treated as variables here (default value empty string)
$ echo '$x = $y + $z' | perl -pe 's/\Q$y + $z/100/'
$x = $y100$z
$ echo '$x = $y + $z' | fs='$y + $z' perl -pe 's/\Q$ENV{fs}/100/'
$x = 100
$ # ENV is preferred since \\ is special in single quoted strings
$ perl -E '$x = q(x\y\\0z); say $x'
x\y\0z
$ x='x\y\\0z' perl -E 'say $ENV{x}'
x\y\\0z
</code></pre><p>If you just want to filter a line based on fixed string, you can also use the <code>index</code> function. This returns the matching position (which starts with <code>0</code>) and <code>-1</code> if the given string wasn't found. See <a href=https://perldoc.perl.org/functions/index>perldoc: index</a> for documentation.<pre><code class=language-bash>$ echo 'int a[5]' | perl -ne 'print if index($_, "a[5]") != -1'
int a[5]
</code></pre><p>The above <code>index</code> example uses double quotes for the string argument, which allows escape sequences like <code>\t</code>, <code>\n</code>, etc and interpolation. This isn't the case with single quoted string values. Using single quotes within the script from command line requires messing with shell metacharacters. So, use <code>q</code> operator instead or pass the fixed string to be matched as an environment variable.<pre><code class=language-bash>$ # double quotes allow escape sequences and interpolation
$ perl -E '$x=5; say "value of x:\t$x"'
value of x:     5

$ # use 'q' operator as an alternate to specify single quoted string
$ s='$a = 2 * ($b + $c)'
$ echo "$s" | perl -ne 'print if index($_, q/($b + $c)/) != -1'
$a = 2 * ($b + $c)

$ # or pass the string as environment variable
$ echo "$s" | fs='($b + $c)' perl -ne 'print if index($_, $ENV{fs}) != -1'
$a = 2 * ($b + $c)
</code></pre><p>You can use the return value of <code>index</code> function to restrict the matching to the start or end of the input line. The line content in <code>$_</code> variable contains the <code>\n</code> line ending character as well. You can either use <code>chomp</code> function explicitly or use the <code>-l</code> command line option, which will be discussed in detail in <a href=./record-separators.html#record-separators>Record separators</a> chapter. For now, it is enough to know that <code>-l</code> will remove the line ending from <code>$_</code> and add it back when <code>print</code> is used.<pre><code class=language-bash>$ cat eqns.txt
a=b,a-b=c,c*d
a+b,pi=3.14,5e12
i*(t+9-g)/8,4-a+b

$ # start of line
$ s='a+b' perl -ne 'print if index($_, $ENV{s})==0' eqns.txt
a+b,pi=3.14,5e12

$ # end of line
$ # same as: s='a+b' perl -ne 'print if /\Q$ENV{s}\E$/' eqns.txt
$ # length function returns number of characters, by default acts on $_
$ # -l option is needed here to remove \n from $_
$ s='a+b' perl -lne '$pos = length() - length($ENV{s});
                     print if index($_, $ENV{s}) == $pos' eqns.txt
i*(t+9-g)/8,4-a+b
</code></pre><p>Here's some more examples using the return value of <code>index</code> function.<pre><code class=language-bash>$ # since 'index' returns '-1' if there's no match,
$ # you need to add >=0 check as well for < or <= comparison
$ perl -ne '$i = index($_, "="); print if 0 <= $i <= 5' eqns.txt
a=b,a-b=c,c*d

$ # > or >= comparison is easy to specify
$ # if you use 3rd argument to 'index', you'll still have to check != -1
$ s='a+b' perl -ne 'print if index($_, $ENV{s})>=1' eqns.txt
i*(t+9-g)/8,4-a+b
</code></pre><p>If you need to match entire input line or field, you can use string comparison operators.<pre><code class=language-bash>$ printf 'a.b\na+b\n' | perl -lne 'print if /^a.b$/'
a.b
a+b
$ printf 'a.b\na+b\n' | perl -lne 'print if $_ eq q/a.b/'
a.b
$ printf '1 a.b\n2 a+b\n' | perl -lane 'print if $F[1] ne q/a.b/'
2 a+b
</code></pre><p>To provide a fixed string in replacement section, environment variable comes in handy again. Or use <code>q</code> operator for directly providing the value, but you may have to workaround the delimiters being used and presence of <code>\\</code> characters.<pre><code class=language-bash>$ # characters like $ and @ are special in replacement section
$ echo 'x+y' | perl -pe 's/\Qx+y/$x+@y/'
+

$ # provide replacement string as environment variable
$ echo 'x+y' | r='$x+@y' perl -pe 's/\Qx+y/$ENV{r}/'
$x+@y

$ # or, use 'e' flag to provide single quoted value as Perl code
$ echo 'x+y' | perl -pe 's/\Qx+y/q($x+@y)/e'
$x+@y

$ # need to workaround delimiters and \\ with 'q' operator based solution
$ echo 'x+y' | perl -pe 's/\Qx+y/q($x\/@y)/e'
$x/@y
$ echo 'x+y' | perl -pe 's|\Qx+y|q($x/@y)|e'
$x/@y
$ echo 'x+y' | perl -pe 's|\Qx+y|q($x/@y\\\z)|e'
$x/@y\\z
</code></pre><h2 id=summary><a class=header href=#summary>Summary</a></h2><p>This chapter showed various examples of processing only lines of interest instead of entire input file. Filtering can be specified using a regexp, fixed string, line number or a combination of them. <code>next</code> and <code>exit</code> are useful to change the flow of code.<h2 id=exercises><a class=header href=#exercises>Exercises</a></h2><p><strong>a)</strong> Remove only the third line of given input.<pre><code class=language-bash>$ seq 34 37 | ##### add your solution here
34
35
37
</code></pre><p><strong>b)</strong> Display only fourth, fifth, sixth and seventh lines for the given input.<pre><code class=language-bash>$ seq 65 78 | ##### add your solution here
68
69
70
71
</code></pre><p><strong>c)</strong> For the input file <code>ip.txt</code>, replace all occurrences of <code>are</code> with <code>are not</code> and <code>is</code> with <code>is not</code> only from line number <strong>4</strong> till end of file. Also, only the lines that were changed should be displayed in the output.<pre><code class=language-bash>$ cat ip.txt
Hello World
How are you
This game is good
Today is sunny
12345
You are funny

##### add your solution here
Today is not sunny
You are not funny
</code></pre><p><strong>d)</strong> For the given <code>stdin</code>, display only the first three lines. Avoid processing lines that are not relevant.<pre><code class=language-bash>$ seq 14 25 | ##### add your solution here
14
15
16
</code></pre><p><strong>e)</strong> For the input file <code>ip.txt</code>, display all lines from start of the file till the first occurrence of <code>game</code>.<pre><code class=language-bash>##### add your solution here
Hello World
How are you
This game is good
</code></pre><p><strong>f)</strong> For the input file <code>ip.txt</code>, display all lines that contain <code>is</code> but not <code>good</code>.<pre><code class=language-bash>##### add your solution here
Today is sunny
</code></pre><p><strong>g)</strong> For the input file <code>ip.txt</code>, extract the word before the whole word <code>is</code> as well as the word after it. If such a match is found, display the two words around <code>is</code> in reversed order. For example, <code>hi;1 is--234 bye</code> should be converted to <code>234:1</code>. Assume that whole word <code>is</code> will not be present more than once in a single line.<pre><code class=language-bash>##### add your solution here
good:game
sunny:Today
</code></pre><p><strong>h)</strong> For the given input string, replace <code>0xA0</code> with <code>0x7F</code> and <code>0xC0</code> with <code>0x1F</code>.<pre><code class=language-bash>$ s='start address: 0xA0, func1 address: 0xC0'

$ echo "$s" | ##### add your solution here
start address: 0x7F, func1 address: 0x1F
</code></pre><p><strong>i)</strong> Find the starting index of first occurrence of <code>is</code> or <code>the</code> or <code>was</code> or <code>to</code> for each input line of the file <code>idx.txt</code>. Assume all input lines will match at least one of these terms.<pre><code class=language-bash>$ cat idx.txt
match after the last newline character
and then you want to test
this is good bye then
you were there to see?

##### add your solution here
12
4
2
9
</code></pre><p><strong>j)</strong> Display all lines containing <code>[4]*</code> for the given <code>stdin</code> data.<pre><code class=language-bash>$ printf '2.3/[4]*6\n2[4]5\n5.3-[4]*9\n' | ##### add your solution here
2.3/[4]*6
5.3-[4]*9
</code></pre><p><strong>k)</strong> For the given input string, replace all lowercase alphabets to <code>x</code> only for words starting with <code>m</code>.<pre><code class=language-bash>$ s='ma2T3a a2p kite e2e3m meet'
$ echo "$s" | ##### add your solution here
xx2T3x a2p kite e2e3m xxxx
</code></pre><p><strong>l)</strong> For the input file <code>ip.txt</code>, delete all characters other than lowercase vowels and newline character. Perform this transformation only between a line containing <code>you</code> up to line number <code>4</code> (inclusive).<pre><code class=language-bash>##### add your solution here
Hello World
oaeou
iaeioo
oaiu
12345
You are funny
</code></pre></main><nav class=nav-wrapper aria-label="Page navigation"><a rel=prev href=one-liner-introduction.html class="mobile-nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=in-place-file-editing.html class="mobile-nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a><div style="clear: both"></div></nav></div></div><nav class=nav-wide-wrapper aria-label="Page navigation"><a rel=prev href=one-liner-introduction.html class="nav-chapters previous"title="Previous chapter"aria-label="Previous chapter"aria-keyshortcuts=Left> <i class="fa fa-angle-left"></i> </a><a rel=next href=in-place-file-editing.html class="nav-chapters next"title="Next chapter"aria-label="Next chapter"aria-keyshortcuts=Right> <i class="fa fa-angle-right"></i> </a></nav></div><script>
            window.playground_copyable = true;
        </script><script src=elasticlunr.min.js charset=utf-8></script><script src=mark.min.js charset=utf-8></script><script src=searcher.js charset=utf-8></script><script src=clipboard.min.js charset=utf-8></script><script src=highlight.js charset=utf-8></script><script src=book.js charset=utf-8></script><script src=sidebar.js></script>